**FREE

ctl-opt nomain thread(*concurrent);


/include 'stream.rpginc'
/include 'stream_int.rpginc'
/include 'streammem.rpginc'
/include 'teraspace.rpginc'

dcl-pr memcpy pointer extproc('memcpy');
  dest pointer value;
  source pointer value;
  count uns(10) value;
end-pr;

dcl-pr memset pointer extproc('memset');
  dest pointer value;
  value int(10) value;
  count uns(10) value;
end-pr;

     
dcl-ds state_t qualified template;
  data pointer;
  length uns(10);
  currentLength uns(10);
  // position of the cursor on the data which has already been read
  //   0 = nothing has been read, it will start on next read at the beginning
  //   5 = 5th byte has been read, on next read it will start with byte 6
  cursor uns(10);
  buffer likeds(iv_stream_buffer_t);
end-ds;


dcl-proc iv_stream_memory_new export;
  dcl-pi *n pointer;
    length uns(10) value;
    data pointer const options(*nopass);
  end-pi;
  
  dcl-s pStream pointer;
  dcl-ds stream likeds(iv_stream_t) based(pStream);
  dcl-ds state likeds(state_t) based(stream.data);
  
  pStream = teraspace_alloc(%size(iv_stream_t));
  stream.blockSize = IV_STREAM_BLOCK_SIZE;
  stream.hasMore = %paddr(iv_stream_memory_hasMore);
  stream.read = %paddr(iv_stream_memory_read);
  stream.write = %paddr(iv_stream_memory_write);
  stream.finalize = %paddr(iv_stream_memory_finalize);
  
  stream.data = teraspace_alloc(%size(state_t));
  
  if (length > 0);
    state.data = teraspace_calloc(length);
  endif;
  
  state.length = length;
  state.currentLength = 0;
  state.cursor = 0;
  state.buffer.data = *null;
  state.buffer.length = 0;
  
  if (%addr(data) <> *null and data <> *null);
    memcpy(state.data : data : length);
    state.currentLength = length;
  endif;
  
  return pStream;
end-proc;


dcl-proc iv_stream_memory_hasMore export;
  dcl-pi *n ind;
    pStream pointer const;
  end-pi;
  
  dcl-ds stream likeds(iv_stream_t) based(pStream);
  dcl-ds state likeds(state_t) based(stream.data);
  
  return state.cursor < state.currentLength ;
end-proc;


dcl-proc iv_stream_memory_read export;
  dcl-pi *n likeds(iv_stream_buffer_t);
    pStream pointer const;
  end-pi;
  
  dcl-ds stream likeds(iv_stream_t) based(pStream);
  dcl-ds state likeds(state_t) based(stream.data);
  dcl-s pStateData pointer;

  if (pStream = *null);
    return *allx'00';
  endif; 

  if (state.buffer.data <> *null);
    memset(state.buffer.data : 0 : state.buffer.length);
  endif;
  state.buffer.length = 0;
  
  if (state.cursor >= state.currentLength);
    return state.buffer;
  endif;

  if (state.currentLength - state.cursor > stream.blockSize);
    state.buffer.length = stream.blockSize;
  else;
    state.buffer.length = state.currentLength - state.cursor;
  endif;
  
  if (state.buffer.length > 0);
    pStateData = state.data + state.cursor;
    if (state.buffer.data = *null);
      state.buffer.data = teraspace_alloc(state.buffer.length);
    endif;
    memcpy(state.buffer.data : pStateData : state.buffer.length);
  endif;
  
  state.cursor += state.buffer.length;
  
  return state.buffer;
end-proc;


dcl-proc iv_stream_memory_write export;
  dcl-pi *n ind;
    pStream pointer const;
    data pointer const;
    length uns(10) value;
  end-pi;

  dcl-ds stream likeds(iv_stream_t) based(pStream);
  dcl-ds state likeds(state_t) based(stream.data);
  dcl-s writeLength uns(10);
  dcl-s pStateData pointer;
  
  if (pStream = *null);
    return *off;
  endif;
  
  if (state.length - state.currentLength >= length);
    writeLength = length;
  else;
    writeLength = state.length - state.currentLength;
  endif;
  
  pStateData = state.data + state.currentLength;
  memcpy(pStateData : data : writeLength);
  
  state.currentLength += writeLength;
  
  return writeLength = length;
end-proc;


dcl-proc iv_stream_memory_finalize export;
  dcl-pi *n;
    pStream pointer;
  end-pi;
  
  dcl-ds stream likeds(iv_stream_t) based(pStream);
  dcl-ds state likeds(state_t) based(stream.data);
  
  if (pStream = *null);
    return;
  endif;
  
  if (stream.data <> *null);
    if (state.data <> *null);
      teraspace_free(state.data);
    endif;
    if (state.buffer.data <> *null);
      teraspace_free(state.buffer.data);
    endif;
    
    teraspace_free(stream.data);
  endif;
  
  teraspace_free(pStream);
end-proc;
