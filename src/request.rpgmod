**FREE

ctl-opt nomain thread(*concurrent);


/include 'httpclient.rpginc'
/include 'memory.rpginc'
/include 'libc.rpginc'
/include 'message/message_h.rpgle'
/include 'noxdb2/noxdb2.rpgle'
/include 'request.rpginc'
/include 'string.rpginc'


dcl-s CRLF char(2) inz(x'0D0A') ccsid(*utf8);
dcl-s UTF8_QUESTION_MARK char(1) inz('?') ccsid(*utf8);
dcl-s UTF8_SPACE char(1) inz ccsid(*utf8);
dcl-s UTF8_COLON char(1) inz(':') ccsid(*utf8);
dcl-s UPPER char(26) ccsid(HTTPCLIENT_ASCII) inz('ABCDEFGHIJKLMNOPQRSTUVWXYZ');
dcl-s LOWER char(26) ccsid(HTTPCLIENT_ASCII) inz('abcdefghijklmnopqrstuvwxyz');

dcl-ds httpclient_request_t qualified template;
  method varchar(10);
  url likeds(httpclient_url_t);
  headers pointer;
  stream pointer;
  content pointer;
  contentSize uns(10);
  binaryContent ind inz(*off);
  headersStreamed ind inz(*off);
  contentStreamed ind inz(*off);
end-ds;


dcl-proc httpclient_request_new export;
  dcl-pi *n pointer;
    method varchar(10) ccsid(HTTPCLIENT_ASCII) const;
    url varchar(HTTPCLIENT_URL_SIZE) ccsid(*utf8) const;
    contentType varchar(1000) ccsid(HTTPCLIENT_ASCII) const options(*nopass);
  end-pi;

  dcl-ds request likeds(httpclient_request_t) based(ptr);
  
  ptr = httpclient_memory_alloc(%size(httpclient_request_t));

  clear request;
  request.method = method;
  request.url = httpclient_url_parse(url);
  request.headers = nox_newObject();

  if (%parms() >= 3);
    nox_setStr(request.headers : 'content-type' : contentType);
  endif;

  return ptr;
end-proc;


dcl-proc httpclient_request_dispose export;
  dcl-pi *n;
    p_request pointer;
  end-pi;

  dcl-ds request likeds(httpclient_request_t) based(p_request);

  if (p_request = *null);
    return;
  endif;

  if (request.content <> *null);
    httpclient_memory_dealloc(request.content);
  endif;

  nox_close(request.headers);

  // TODO dealloc stream

  httpclient_memory_dealloc(p_request);
end-proc;


dcl-proc httpclient_request_toString export;
  dcl-pi *n likeds(httpclient_string_t);
    p_request pointer const;
  end-pi;

  dcl-ds request likeds(httpclient_request_t) based(p_request);
  dcl-ds iterator likeds(nox_iterator);
  dcl-s data varchar(100000) ccsid(*utf8);
  dcl-s headerName varchar(1000) ccsid(*utf8);
  dcl-s headerValue varchar(10000) ccsid(*utf8);
  dcl-ds serialized likeds(httpclient_string_t);
  dcl-s body pointer;

  serialized = httpclient_string_new(1048576);

  // TODO CONNECT message has different request line, see HTTP/1.1 spec
  // TODO percent-encode header
  // TODO need to check that we have enough space for the headers when adding them

  data = request.method + UTF8_SPACE + request.url.path;
  if (%len(request.url.query) > 0);
    data += UTF8_QUESTION_MARK + request.url.query;
  endif;
  data += ' HTTP/1.1' + CRLF;
  
  // Host
  data += 'Host: ' + request.url.host + UTF8_COLON + %char(request.url.port) + CRLF;
  
  // user-agent
  data += 'User-Agent: ILEvator for IBM i/' + ILEVATOR_VERSION + CRLF;
  
  iterator = nox_setIterator(request.headers);
  dow (nox_forEach(iterator));
    headerName = nox_getName(iterator.this);
    headerValue = nox_getValueStr(iterator.this);
    data+= headerName + UTF8_COLON + headerValue + CRLF;
  enddo;
  
  data += CRLF;
  
  memcpy(serialized.value : %addr(data : *data) : %len(data));
  serialized.size = strlen(serialized.value);
  
  body = serialized.value + serialized.size;

  if (request.content <> *null and request.contentSize > 0);
    memcpy(body : request.content : request.contentSize);
    // encoding? mime type , charset attribute? defaults?
  endif;
  
  // Note: no ending CRLF after body !!!

  return serialized;
end-proc;


dcl-proc httpclient_request_setHeader export;
  dcl-pi *n;
    p_request pointer const;
    name varchar(100) ccsid(HTTPCLIENT_ASCII) const;
    value varchar(8000) ccsid(HTTPCLIENT_ASCII) const;
  end-pi;

  dcl-ds request likeds(httpclient_request_t) based(p_request);
  dcl-s lowerName varchar(100) ccsid(HTTPCLIENT_ASCII);
  
  lowerName = %xlate(LOWER : UPPER : name);
  
  nox_setStr(request.headers : lowerName : value);
end-proc;


dcl-proc httpclient_request_setContentType export;
  dcl-pi *n;
    p_request pointer const;
    contentType varchar(1000) ccsid(HTTPCLIENT_ASCII) const;
  end-pi;

  dcl-ds request likeds(httpclient_request_t) based(p_request);

  nox_setStr(request.headers : 'content-type' : contentType);
end-proc;


dcl-proc httpclient_request_setTextBody export;
  dcl-pi *n;
    requestPtr pointer const;
    content varchar(100000) value;
  end-pi;

  dcl-ds request likeds(httpclient_request_t) based(requestPtr);

  if (request.content <> *null);
    httpclient_memory_dealloc(request.content);
  endif;

  request.binaryContent = *off;
  request.contentSize = %len(content);
  request.content = httpclient_memory_alloc(%len(content));
  memcpy(request.content : %addr(content : *data) : %len(content));
end-proc;


dcl-proc httpclient_request_setBinaryBody export;
  dcl-pi *n;
    p_request pointer const;
    content pointer const;
    size uns(10) const;
  end-pi;

  dcl-ds request likeds(httpclient_request_t) based(p_request);

  if (request.content <> *null);
    httpclient_memory_dealloc(request.content);
  endif;

  request.binaryContent = *on;
  request.contentSize = size;
  request.content = httpclient_memory_alloc(size);
  memcpy(request.content : content : size);
end-proc;


dcl-proc httpclient_request_setStream export;
  dcl-pi *n;
    p_request pointer const;
    stream pointer const;
  end-pi;

  dcl-ds request likeds(httpclient_request_t) based(p_request);

  request.stream = stream;
end-proc;


dcl-proc httpclient_request_hasStream export;
  dcl-pi *n ind;
    p_request pointer const;
  end-pi;

  dcl-ds request likeds(httpclient_request_t) based(p_request);

  return request.stream <> *null;
end-proc;


dcl-proc httpclient_request_hasTextBody export;
  dcl-pi *n ind;
    p_request pointer const;
  end-pi;

  dcl-ds request likeds(httpclient_request_t) based(p_request);

  return request.content <> *null;
end-proc;


dcl-proc httpclient_request_hasBody export;
  dcl-pi *n ind;
    p_request pointer const;
  end-pi;

  dcl-ds request likeds(httpclient_request_t) based(p_request);

  return request.stream <> *null or request.content <> *null;
end-proc;
