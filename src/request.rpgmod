**FREE

ctl-opt nomain thread(*concurrent);


/include 'teraspace.rpginc'
/include 'libc.rpginc'
/include 'message.rpginc'
/include 'mime.rpginc'
/include 'simpleList.rpginc'
/include 'request.rpginc'
/include 'url.rpginc'
/include 'varchar.rpginc'
/include 'xlate.rpginc'


dcl-c ASCII 367;
dcl-c ANSI 437;
dcl-s CRLF char(2) inz(x'0D0A') ccsid(*utf8);
dcl-s UTF8_SLASH char(1) inz('/') ccsid(*utf8);
dcl-s UTF8_QUESTION_MARK char(1) inz('?') ccsid(*utf8);
dcl-s UTF8_SPACE char(1) inz ccsid(*utf8);
dcl-s UTF8_COLON char(1) inz(':') ccsid(*utf8);
dcl-s UPPER char(26) ccsid(*utf8) inz('ABCDEFGHIJKLMNOPQRSTUVWXYZ');
dcl-s LOWER char(26) ccsid(*utf8) inz('abcdefghijklmnopqrstuvwxyz');

dcl-ds iv_request_t qualified template;
  method varchar(10);
  url likeds(iv_url_t);
  headers pointer;
  stream pointer;
  content pointer;
  contentSize uns(10);
  binaryContent ind inz(*off);
  headersStreamed ind inz(*off);
  contentStreamed ind inz(*off);
end-ds;


dcl-proc iv_request_new_packedUrl export;
  dcl-pi *n pointer;
    method varchar(12) value;
    url varchar(IV_REQUEST_URL_SIZE) ccsid(*utf8) value;
    acceptMimeType varchar(IV_REQUEST_HEADER_VALUE_SIZE) ccsid(*utf8) value options(*nopass);
  end-pi;

  dcl-ds request likeds(iv_request_t) based(ptr);

  ptr = teraspace_alloc(%size(iv_request_t));

  clear request;
  request.method = method;
  request.url = iv_url_parse(url);
  request.headers = sList_new();

  if (%parms() >= 3 and %addr(acceptMimeType) <> *null and %len(acceptMimeType) > 0);
    iv_request_addHeader(ptr : 'accept' : acceptMimeType);
  endif;

  return ptr;
end-proc;


dcl-proc iv_request_new_unpackedUrl export;
  dcl-pi *n pointer;
    method varchar(12) value;
    host pointer value options(*string);
    port int(10) value;
    path pointer value options(*string);
    query pointer value options(*string);
    acceptMimeType varchar(IV_REQUEST_HEADER_VALUE_SIZE) ccsid(*utf8) value options(*nopass);
  end-pi;

  dcl-ds request likeds(iv_request_t) based(ptr);

  ptr = teraspace_alloc(%size(iv_request_t));

  clear request;
  request.method = method;
  request.url.host = %str(host : %size(request.url.host));
  request.url.port = port;
  request.url.path = %str(path : %size(request.url.path));
  request.url.query = %str(query : %size(request.url.query));
  request.headers = sList_new();

  if (%parms() >= 6 and %addr(acceptMimeType) <> *null and %len(acceptMimeType) > 0);
    iv_request_addHeader(ptr : 'accept' : acceptMimeType);
  endif;

  return ptr;
end-proc;


dcl-proc iv_request_dispose export;
  dcl-pi *n;
    p_request pointer;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);

  if (p_request = *null);
    return;
  endif;

  if (request.content <> *null);
    teraspace_free(request.content);
  endif;

  deallocateHeaders(request.headers);

  // TODO dealloc stream

  teraspace_free(p_request);
end-proc;


dcl-proc iv_request_toString export;
  dcl-pi *n likeds(LVARPUCHAR_t);
    p_request pointer const;
  end-pi;

  dcl-c SERIALIZED_INIT_SIZE 1048576;
  dcl-ds serialized likeds(LVARPUCHAR_t);
  dcl-s sizeAllocated uns(10);
  dcl-s sizeUsed uns(10);

  dcl-ds request likeds(iv_request_t) based(p_request);
  dcl-ds iterator likeds(SLISTITERATOR_t);
  dcl-ds node likeds(SLISTNODE_t) based(iterator.pThis);
  dcl-ds nodePayload likeds(SLISTKEYVAL_t) based(node.payloadData);
  dcl-s data varchar(SERIALIZED_INIT_SIZE) ccsid(*utf8);
  dcl-s headerName varchar(IV_REQUEST_HEADER_NAME_SIZE) ccsid(*utf8);
  dcl-s headerValue varchar(IV_REQUEST_HEADER_VALUE_SIZE) ccsid(*utf8);
  dcl-ds tmpSerializedContent likeds(LVARPUCHAR_t);
  dcl-s translatedLength uns(10);
  dcl-s hasContentTypeHeader ind inz(*off);
  dcl-s hasAcceptHeader ind inz(*off);

  if (request.contentSize > SERIALIZED_INIT_SIZE);
      sizeAllocated = SERIALIZED_INIT_SIZE + request.contentSize;
  else;
      sizeAllocated = SERIALIZED_INIT_SIZE;
  endif;

  serialized.length = 0;
  serialized.string = teraspace_alloc(sizeAllocated);

  // TODO CONNECT message has different request line, see HTTP/1.1 spec

  data = request.method + UTF8_SPACE;
  if (%len(request.url.path) = 0);
    data += UTF8_SLASH;
  else;
    data += request.url.path;
  endif;
  if (%len(request.url.query) > 0);
    data += UTF8_QUESTION_MARK + request.url.query;
  endif;
  data += ' HTTP/1.1' + CRLF;
  data += 'Host: ' + request.url.host + UTF8_COLON + %char(request.url.port) + CRLF;
  data += 'Connection: keep-alive' + CRLF;

  iterator = sList_setIterator(request.headers);
  dow (sList_foreach(iterator));
    headerName = %str(nodePayload.key.string : nodePayload.key.length);
    headerValue = %str(nodePayload.value.string : nodePayload.value.length);
    // TODO encode header names and values (only ASCII allowed)
    // TODO need to check that we have enough space for the headers when adding them
    data+= headerName + UTF8_COLON + headerValue + CRLF;

    if (headerName = 'content-type');
      hasContentTypeHeader = *on;
    endif;

    if (headerName = 'accept');
      hasAcceptHeader = *on;
    endif;
  enddo;

  if (not hasAcceptHeader);
    data += 'Accept: */*' + CRLF;
  endif;

  if (request.content <> *null);
    // request.contentSize may not be the real size after char conversion
    data+= 'content-length' + UTF8_COLON + %char(request.contentSize) + CRLF;

    if (not hasContentTypeHeader);
      if (request.binaryContent);
        data += 'content-type: application/octet-stream' + CRLF;
      else;
        data += 'content-type: text/plain' + CRLF;
      endif;
    endif;
  endif;

  data += CRLF;

  serialized.length = %len(data);
  memcpy(serialized.string : %addr(data : *data) : %len(data));

  if (request.content <> *null and request.contentSize > 0);
    if (request.binaryContent);
      memcpy(serialized.string + serialized.length : request.content : request.contentSize);
      serialized.length += request.contentSize;
    else;
      // assume the worst : size * 4
      tmpSerializedContent.length = request.contentSize * 4;
      tmpSerializedContent.string = teraspace_alloc(tmpSerializedContent.length);
      translatedLength = serializeContent(tmpSerializedContent : p_request);

      if (serialized.length + translatedLength > sizeAllocated);
        sizeAllocated = serialized.length + translatedLength;
        serialized.string = teraspace_realloc(serialized.string : sizeAllocated);
      endif;

      if (translatedLength > 0);
        memcpy(serialized.string + serialized.length : tmpSerializedContent.string : translatedLength);
        serialized.length += translatedLength;
      endif;

      teraspace_free(tmpSerializedContent.string);
    endif;
  endif;

  // Note: no ending CRLF after body !!!

  return serialized;
end-proc;


dcl-proc iv_request_addHeader export;
  dcl-pi *n;
    p_request pointer const;
    name varchar(IV_REQUEST_HEADER_NAME_SIZE) ccsid(*utf8) const;
    value varchar(IV_REQUEST_HEADER_VALUE_SIZE) ccsid(*utf8) const;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);
  dcl-s lowerName varchar(IV_REQUEST_HEADER_NAME_SIZE) ccsid(*utf8);
  dcl-ds listKey likeds(LVARPUCHAR_t);
  dcl-ds listValue likeds(LVARPUCHAR_t);

  if (name = *blank);
    return;
  endif;

  // TODO use OS API for proper conversion
  lowerName = %xlate(UPPER : LOWER : name);

  listKey.length = %len(lowerName);
  listKey.string = teraspace_alloc(listKey.length + 1);
  %str(listKey.string : listKey.length + 1) = lowerName;
  listValue.length = %len(value);
  listValue.string = teraspace_alloc(listValue.length + 1);
  %str(listValue.string : listValue.length + 1) = value;
  sList_pushLVPC(request.headers : listKey : listValue);
end-proc;


dcl-proc iv_request_addHeaders export;
    dcl-pi *n;
        p_request pointer value;
        headers pointer value;
    end-pi;

    dcl-ds request likeds(iv_request_t) based(p_request);
    dcl-ds iterator likeds(SLISTITERATOR_t);
    dcl-ds node likeds(SLISTNODE_t) based(iterator.pThis);
    dcl-ds nodePayload likeds(SLISTKEYVAL_t) based(node.payloadData);
    dcl-s headerName varchar(IV_REQUEST_HEADER_NAME_SIZE) ccsid(*utf8);
    dcl-s headerValue varchar(IV_REQUEST_HEADER_VALUE_SIZE) ccsid(*utf8);

    iterator = sList_setIterator(headers);
    dow (sList_foreach(iterator));
        headerName = %str(nodePayload.key.string : nodePayload.key.length);
        headerValue = %str(nodePayload.value.string : nodePayload.value.length);
        iv_request_addHeader(p_request : headerName : headerValue);
    enddo;
end-proc;


dcl-proc iv_request_getHeader export;
  dcl-pi *n varchar(8000) ccsid(*utf8);
    p_request pointer const;
    name varchar(IV_REQUEST_HEADER_NAME_SIZE) ccsid(*utf8) const;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);
  dcl-s value varchar(8000) ccsid(*utf8);
  dcl-ds iterator likeds(SLISTITERATOR_t);
  dcl-ds node likeds(SLISTNODE_t) based(iterator.pThis);
  dcl-ds nodePayload likeds(SLISTKEYVAL_t) based(node.payloadData);
  dcl-s lowerName varchar(IV_REQUEST_HEADER_NAME_SIZE) ccsid(*utf8);
  dcl-s headerName varchar(IV_REQUEST_HEADER_NAME_SIZE) ccsid(*utf8);

  lowerName = %xlate(UPPER : LOWER : name);

  iterator = sList_setIterator(request.headers);
  dow (sList_foreach(iterator));
    headerName = %str(nodePayload.key.string : nodePayload.key.length);

    if (headerName = lowerName);
      value = %str(nodePayload.value.string : nodePayload.value.length);
      leave;
    endif;
  enddo;

  return value;
end-proc;


dcl-proc iv_request_setContentType export;
  dcl-pi *n;
    p_request pointer const;
    contentType varchar(IV_REQUEST_HEADER_VALUE_SIZE) ccsid(*utf8) const;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);

  iv_request_addHeader(p_request : 'content-type' : contentType);
end-proc;


dcl-proc iv_request_setAcceptMimeType export;
  dcl-pi *n;
    p_request pointer const;
    contentType varchar(IV_REQUEST_HEADER_VALUE_SIZE) ccsid(*utf8) const;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);

  iv_request_addHeader(p_request : 'content-type' : contentType);
end-proc;


dcl-proc iv_request_setTextBody export;
  dcl-pi *n;
    p_request pointer value;
    content varchar(1048576) value;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);

  if (request.content <> *null);
    teraspace_free(request.content);
  endif;

  request.binaryContent = *off;
  request.contentSize = %len(content);
  request.content = teraspace_alloc(%len(content));
  memcpy(request.content : %addr(content : *data) : %len(content));
end-proc;


dcl-proc iv_request_setBinaryBody export;
  dcl-pi *n;
    p_request pointer value;
    content pointer value;
    size uns(10) value;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);

  if (request.content <> *null);
    teraspace_free(request.content);
  endif;

  request.binaryContent = *on;
  request.contentSize = size;
  request.content = teraspace_alloc(size);
  memcpy(request.content : content : size);
end-proc;


dcl-proc iv_request_setFormBody export;
  dcl-pi *n;
    p_request pointer value;
    formData likeds(LVARPUCHAR_t) value;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);

  // we use binary content here because the form data is already in ASCII and
  // should not be converted to any other CCSID
  request.binaryContent = *on;

  request.contentSize = formData.Length;
  request.content = teraspace_alloc(formData.Length);
  memcpy(request.content : formData.String : formData.Length);

  teraspace_free(formData.String);
end-proc;


dcl-proc iv_request_setStream export;
  dcl-pi *n;
    p_request pointer const;
    stream pointer const;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);

  request.stream = stream;
end-proc;


dcl-proc iv_request_hasStream export;
  dcl-pi *n ind;
    p_request pointer const;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);

  return request.stream <> *null;
end-proc;


dcl-proc iv_request_hasTextBody export;
  dcl-pi *n ind;
    p_request pointer const;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);

  return request.content <> *null;
end-proc;


dcl-proc iv_request_hasBody export;
  dcl-pi *n ind;
    p_request pointer const;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);

  return request.stream <> *null or request.content <> *null;
end-proc;


dcl-proc deallocateHeaders;
  dcl-pi *n;
    list pointer;
  end-pi;

  dcl-ds iterator likeds(SLISTITERATOR_t) inz;
  dcl-ds node likeds(SLISTNODE_t) based(iterator.pThis);
  dcl-ds payload likeds(SLISTKEYVAL_t) based(node.payloadData);

  iterator = sList_setIterator(list);

  dow (sList_foreach(iterator));
    teraspace_free(payload.key.string);
    teraspace_free(payload.value.string);
  enddo;

  sList_free(list);
end-proc;


dcl-proc serializeContent;
  dcl-pi *n uns(10);
    serialized likeds(LVARPUCHAR_t);
    p_request pointer const;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);
  dcl-s outLength uns(10);
  dcl-s ccsid int(10);
  dcl-s contentTypeHeader varchar(1000) ccsid(*utf8);

  if (request.content = *null or request.contentSize = 0);
    return 0;
  endif;

  contentTypeHeader = getContentTypeHeader(request.headers);
  ccsid = iv_mime_getCcsid(contentTypeHeader);
  if (ccsid = 0);
    ccsid = 1208; // default to utf-8
  endif;

  outLength = xlate_translateBuffer(serialized.string  :
      request.content : request.contentSize : 0 : ccsid);
  serialized.length = outLength;

  return outLength;
end-proc;


dcl-proc getContentTypeHeader;
  dcl-pi *n varchar(IV_REQUEST_HEADER_VALUE_SIZE) ccsid(*utf8);
    list pointer;
  end-pi;

  dcl-ds iterator likeds(SLISTITERATOR_t) inz;
  dcl-ds node likeds(SLISTNODE_t) based(iterator.pThis);
  dcl-ds payload likeds(SLISTKEYVAL_t) based(node.payloadData);

  iterator = sList_setIterator(list);

  dow (sList_foreach(iterator));
    if (%str(payload.key.string : payload.key.length) = 'content-type');
      return %str(payload.value.string : payload.value.length);
    endif;
  enddo;

  return *blank;
end-proc;
