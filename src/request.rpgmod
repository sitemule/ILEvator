**FREE

ctl-opt nomain thread(*concurrent);


/include 'teraspace.rpginc'
/include 'libc.rpginc'
/include 'message.rpginc'
/include 'mime.rpginc'
/include 'simpleList.rpginc'
/include 'request.rpginc'
/include 'url.rpginc'
/include 'varchar.rpginc'
/include 'xlate.rpginc'


dcl-c ASCII 367;
dcl-c ANSI 437;
dcl-c URL_SIZE 65530;
dcl-s CRLF char(2) inz(x'0D0A') ccsid(*utf8);
dcl-s UTF8_SLASH char(1) inz('/') ccsid(*utf8);
dcl-s UTF8_QUESTION_MARK char(1) inz('?') ccsid(*utf8);
dcl-s UTF8_SPACE char(1) inz ccsid(*utf8);
dcl-s UTF8_COLON char(1) inz(':') ccsid(*utf8);
dcl-s UPPER char(26) ccsid(*utf8) inz('ABCDEFGHIJKLMNOPQRSTUVWXYZ');
dcl-s LOWER char(26) ccsid(*utf8) inz('abcdefghijklmnopqrstuvwxyz');
dcl-c ILEVATOR_VERSION '0.1.0';

dcl-ds iv_request_t qualified template;
  method varchar(10);
  url likeds(iv_url_t);
  headers pointer;
  stream pointer;
  content pointer;
  contentSize uns(10);
  binaryContent ind inz(*off);
  headersStreamed ind inz(*off);
  contentStreamed ind inz(*off);
end-ds;


dcl-proc iv_request_new export;
  dcl-pi *n pointer;
    method varchar(10) const;
    url varchar(URL_SIZE) ccsid(*utf8) const;
    acceptMimeType varchar(1000) ccsid(*utf8) const options(*nopass);
  end-pi;

  dcl-ds request likeds(iv_request_t) based(ptr);
  
  ptr = teraspace_alloc(%size(iv_request_t));

  clear request;
  request.method = method;
  request.url = iv_url_parse(url);
  request.headers = sList_new();

  if (%parms() >= 3 and %len(acceptMimeType) > 0);
    iv_request_addHeader(ptr : 'accept' : acceptMimeType);
  endif;

  return ptr;
end-proc;


dcl-proc iv_request_dispose export;
  dcl-pi *n;
    p_request pointer;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);

  if (p_request = *null);
    return;
  endif;

  if (request.content <> *null);
    teraspace_free(request.content);
  endif;

  deallocateHeaders(request.headers);

  // TODO dealloc stream

  teraspace_free(p_request);
end-proc;


dcl-proc iv_request_toString export;
  dcl-pi *n likeds(LVARPUCHAR_t);
    p_request pointer const;
  end-pi;
  
  dcl-c SERIALIZED_INIT_SIZE 1048576;
  dcl-ds serialized likeds(LVARPUCHAR_t);
  dcl-s sizeAllocated uns(10);
  dcl-s sizeUsed uns(10);
  
  dcl-ds request likeds(iv_request_t) based(p_request);
  dcl-ds iterator likeds(SLISTITERATOR_t);
  dcl-ds node likeds(SLISTNODE_t) based(iterator.pThis);
  dcl-ds nodePayload likeds(SLISTKEYVAL_t) based(node.payloadData);
  dcl-s data varchar(SERIALIZED_INIT_SIZE) ccsid(*utf8);
  dcl-s headerName varchar(1000) ccsid(*utf8);
  dcl-s headerValue varchar(10000) ccsid(*utf8);

  // TODO check content size , if content size > init size => adjust init size

  sizeAllocated = SERIALIZED_INIT_SIZE;
  serialized.length = 0;
  serialized.string = teraspace_alloc(SERIALIZED_INIT_SIZE);

  // TODO CONNECT message has different request line, see HTTP/1.1 spec

  data = request.method + UTF8_SPACE;
  if (%len(request.url.path) = 0);
    data += UTF8_SLASH;
  else;
    data += request.url.path;
  endif;
  if (%len(request.url.query) > 0);
    data += UTF8_QUESTION_MARK + request.url.query;
  endif;
  data += ' HTTP/1.1' + CRLF;
  data += 'Host: ' + request.url.host + UTF8_COLON + %char(request.url.port) + CRLF;
  data += 'User-Agent: ILEvator for IBM i/' + ILEVATOR_VERSION + CRLF;
  
  iterator = sList_setIterator(request.headers);
  dow (sList_foreach(iterator));
    headerName = %str(nodePayload.key.string : nodePayload.key.length);
    headerValue = %str(nodePayload.value.string : nodePayload.value.length);
    // TODO encode header names and values (only ASCII allowed)
    // TODO need to check that we have enough space for the headers when adding them
    data+= headerName + UTF8_COLON + headerValue + CRLF;
  enddo;
  
  data += CRLF;
  
  
  serialized.length = %len(data);
  memcpy(serialized.string : %addr(data : *data) : %len(data));
  
  if (request.content <> *null and request.contentSize > 0);
    if (request.binaryContent);
      memcpy(serialized.string + serialized.length : request.content : request.contentSize);
      serialized.length += request.contentSize;
    else;
      // check available space (... and assume the worst : size * 4)
      if (serialized.length + request.contentSize * 4 > sizeAllocated);
        sizeAllocated = serialized.length + request.contentSize * 4;
        serialized.string = teraspace_realloc(serialized.string : sizeAllocated);
      endif;
      
      serializeContent(serialized : p_request);
    endif;
  endif;
  
  // Note: no ending CRLF after body !!!

  return serialized;
end-proc;


dcl-proc iv_request_addHeader export;
  dcl-pi *n;
    p_request pointer const;
    name varchar(100) ccsid(*utf8) const;
    value varchar(8000) ccsid(*utf8) const;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);
  dcl-s lowerName varchar(100) ccsid(*utf8);
  dcl-ds listKey likeds(LVARPUCHAR_t);
  dcl-ds listValue likeds(LVARPUCHAR_t);
  
  if (name = *blank);
    return;
  endif;
  
  // TODO use OS API for proper conversion
  lowerName = %xlate(LOWER : UPPER : name);
  
  listKey.length = %len(name);
  listKey.string = teraspace_alloc(listKey.length + 1);
  %str(listKey.string : listKey.length + 1) = name;
  listValue.length = %len(value);
  listValue.string = teraspace_alloc(listValue.length + 1);
  %str(listValue.string : listValue.length + 1) = value;
  sList_pushLVPC(request.headers : listKey : listValue);
end-proc;


dcl-proc iv_request_setContentType export;
  dcl-pi *n;
    p_request pointer const;
    contentType varchar(1000) ccsid(*utf8) const;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);

  iv_request_addHeader(p_request : 'content-type' : contentType);
end-proc;


dcl-proc iv_request_setAcceptMimeType export;
  dcl-pi *n;
    p_request pointer const;
    contentType varchar(1000) ccsid(*utf8) const;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);

  iv_request_addHeader(p_request : 'content-type' : contentType);
end-proc;


dcl-proc iv_request_setTextBody export;
  dcl-pi *n;
    requestPtr pointer const;
    content varchar(1000000) value;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(requestPtr);

  if (request.content <> *null);
    teraspace_free(request.content);
  endif;

  request.binaryContent = *off;
  request.contentSize = %len(content);
  request.content = teraspace_alloc(%len(content));
  memcpy(request.content : %addr(content : *data) : %len(content));
end-proc;


dcl-proc iv_request_setBinaryBody export;
  dcl-pi *n;
    p_request pointer const;
    content pointer const;
    size uns(10) const;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);

  if (request.content <> *null);
    teraspace_free(request.content);
  endif;

  request.binaryContent = *on;
  request.contentSize = size;
  request.content = teraspace_alloc(size);
  memcpy(request.content : content : size);
end-proc;


dcl-proc iv_request_setStream export;
  dcl-pi *n;
    p_request pointer const;
    stream pointer const;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);

  request.stream = stream;
end-proc;


dcl-proc iv_request_hasStream export;
  dcl-pi *n ind;
    p_request pointer const;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);

  return request.stream <> *null;
end-proc;


dcl-proc iv_request_hasTextBody export;
  dcl-pi *n ind;
    p_request pointer const;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);

  return request.content <> *null;
end-proc;


dcl-proc iv_request_hasBody export;
  dcl-pi *n ind;
    p_request pointer const;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);

  return request.stream <> *null or request.content <> *null;
end-proc;


dcl-proc deallocateHeaders;
  dcl-pi *n;
    list pointer;
  end-pi;
  
  dcl-ds iterator likeds(SLISTITERATOR_t) inz;
  dcl-ds node likeds(SLISTNODE_t) based(iterator.pThis);
  dcl-ds payload likeds(SLISTKEYVAL_t) based(node.payloadData);
  
  iterator = sList_setIterator(list);
  
  dow (sList_foreach(iterator));
    teraspace_free(payload.key.string);
    teraspace_free(payload.value.string);
  enddo;
  
  sList_free(list);
end-proc;


dcl-proc serializeContent;
  dcl-pi *n;
    serialized likeds(LVARPUCHAR_t);
    p_request pointer const;
  end-pi;

  dcl-ds request likeds(iv_request_t) based(p_request);
  dcl-s outLength uns(10);
  dcl-s ccsid int(10);
  dcl-s contentTypeHeader varchar(1000) ccsid(*utf8);
  
  if (request.content = *null or request.contentSize = 0);
    return;
  endif;
  
  contentTypeHeader = getContentTypeHeader(request.headers);
  ccsid = iv_mime_getCcsid(contentTypeHeader);
  if (ccsid = 0);
    ccsid = 1208; // default to utf-8
  endif;
  
  outLength = xlate_translateBuffer(serialized.string + serialized.length : 
      request.content : request.contentSize : 0 : ccsid);
  serialized.length += outLength;
end-proc;


dcl-proc getContentTypeHeader;
  dcl-pi *n varchar(1000) ccsid(*utf8);
    list pointer;
  end-pi;
  
  dcl-ds iterator likeds(SLISTITERATOR_t) inz;
  dcl-ds node likeds(SLISTNODE_t) based(iterator.pThis);
  dcl-ds payload likeds(SLISTKEYVAL_t) based(node.payloadData);
  
  iterator = sList_setIterator(list);
  
  dow (sList_foreach(iterator));
    if (%str(payload.key.string : payload.key.length) = 'content-type');
      return %str(payload.value.string : payload.value.length);
    endif;
  enddo;
  
  return *blank;
end-proc;

